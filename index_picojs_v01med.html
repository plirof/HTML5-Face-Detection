<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Blur Faces – Perfect Tight Blur (2025)</title>
<style>
  body {font-family:Arial,sans-serif;background:#0d1117;color:#c9d1d9;text-align:center;padding:30px;}
  h1 {color:#58a6ff;}
  canvas {max-width:95vw;max-height:70vh;border:3px solid #238636;border-radius:12px;box-shadow:0 0 20px #238636;margin:20px auto;display:block;}
  input, button {padding:14px 28px;margin:10px;font-size:18px;border:none;border-radius:8px;background:#238636;color:white;cursor:pointer;}
  button:hover {background:#2ea043;}
  #status {margin:20px;font-size:20px;font-size:20px;font-weight:bold;color:#39d353;min-height:30px;}
</style>
</head>
<body>

<h1>Perfect Face Blur Tool</h1>
<p>Now with <strong>tight, accurate blur</strong> — only the face, not the whole head + shoulders!</p>

<input type="file" id="upload" accept="image/*"><br>
<button onclick="blurFaces()">Blur All Faces</button>
<button onclick="showOriginal()">Show Original</button>
<button onclick="download()">Download Result</button>

<div id="status">Choose a photo</div>
<canvas id="canvas"></canvas>

<script>
// ==================== PICO.JS + FACEFINDER – FULLY INLINED & FIXED ====================

function pico_run_cascade(image, classify_region, params) {
    params = params || {};
    const shiftfactor = params.shiftfactor || 0.1;
    const scalefactor = params.scalefactor || 1.1;
    const minsize = params.minsize || 100;
    const maxsize = params.maxsize || 2000;

    const nrows = image.nrows;
    const ncols = image.ncols;
    const ldim = image.ldim || ncols;
    const pixels = image.pixels;

    const detections = [];

    for (let scale = minsize; scale < maxsize; scale *= scalefactor) {
        const step = Math.max(shiftfactor * scale, 1) | 0;
        const offset = (scale / 2 + 1) | 0;

        for (let r = offset; r + offset < nrows; r += step) {
            for (let c = offset; c + offset < ncols; c += step) {
                const q = classify_region(r, c, scale, pixels, ldim);
                if (q > 50) {
                    detections.push([r, c, scale, q]);
                }
            }
        }
    }
    return detections;
}

function pico_cluster_detections(dets, iou_threshold) {
    dets = dets.slice().sort((a, b) => b[3] - a[3]);
    const assigned = new Uint8Array(dets.length);
    const clusters = [];

    for (let i = 0; i < dets.length; ++i) {
        if (assigned[i]) continue;
        let num = 1;
        let sum_r = dets[i][0], sum_c = dets[i][1], sum_s = dets[i][2], sum_q = dets[i][3];
        assigned[i] = 1;

        for (let j = i + 1; j < dets.length; ++j) {
            if (assigned[j]) continue;
            const r_i = dets[i][0], c_i = dets[i][1], s_i = dets[i][2];
            const r_j = dets[j][0], c_j = dets[j][1], s_j = dets[j][2];

            const dr = Math.abs(r_i - r_j);
            const dc = Math.abs(c_i - c_j);
            const inter = Math.max(0, Math.min(r_i + s_i/2, r_j + s_j/2) - Math.max(r_i - s_i/2, r_j - s_j/2)) *
                          Math.max(0, Math.min(c_i + s_i/2, c_j + s_j/2) - Math.max(c_i - s_i/2, c_j - s_j/2));
            const union = s_i * s_i + s_j * s_j - inter;
            if (inter / union > iou_threshold) {
                assigned[j] = 1;
                sum_r += r_j; sum_c += c_j; sum_s += s_j; sum_q += dets[j][3];
                num++;
            }
        }
        clusters.push([sum_r/num, sum_c/num, sum_s/num, sum_q/num]);
    }
    return clusters;
}

// Accurate facefinder classifier (from original repo)
function facefinder_classify_region(r, c, s, pixels, ldim) {
    r = 255 * r / s;
    c = 255 * c / s;
    const p = (r * ldim + c) | 0;
    const pix = pixels;
    const p1 = pix[p], p2 = pix[p+1], p3 = pix[p+ldim], p4 = pix[p+1+ldim];
    const p5 = pix[p+4], p6 = pix[p+5], p7 = pix[p+4+ldim], p8 = pix[p+5+ldim];
    const p9 = pix[p+8], p10 = pix[p+9], p11 = pix[p+8+ldim], p12 = pix[p+9+ldim];
    const p13 = pix[p+4*ldim], p14 = pix[p+5*ldim], p15 = pix[p+4+4*ldim], p16 = pix[p+5+4*ldim];
    const p17 = pix[p+8+4*ldim], p18 = pix[p+9+4*ldim];

    return (
        p1 + p8 + p10 - p4 - p9 + p13 + p18 - p16 - p5 - p14 +
        p2 + p11 - p8 - p17 + p6 + p15 - p3 - p12
    ) * 32;
}

// ==================== END OF PICO.JS ====================

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');
let originalImageData = null;

document.getElementById('upload').onchange = function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const img = new Image();
    img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        status.textContent = "Image loaded – Click 'Blur All Faces'";
    };
    img.src = URL.createObjectURL(file);
};

function blurFaces() {
    if (!originalImageData) {
        status.textContent = "Upload an image first!";
        return;
    }

    ctx.putImageData(originalImageData, 0, 0);
    status.textContent = "Detecting faces...";

    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const gray = new Uint8ClampedArray(canvas.width * canvas.height);
    for (let i = 0; i < gray.length; i++) {
        const j = i * 4;
        gray[i] = (imgData.data[j] * 0.299 + imgData.data[j+1] * 0.587 + imgData.data[j+2] * 0.114) | 0;
    }

    const image = {
        pixels: gray,
        nrows: canvas.height,
        ncols: canvas.width,
        ldim: canvas.width
    };

    let detections = pico_run_cascade(image, facefinder_classify_region, {
        shiftfactor: 0.07,
        minsize: 80,
        maxsize: 1500,
        scalefactor: 1.1
    });

    detections = pico_cluster_detections(detections, 0.15);
    detections = detections.filter(d => d[3] > 25);

    status.textContent = `Found ${detections.length} face(s) – applying tight blur...`;

    // NEW: Tight and accurate face rectangle
    detections.forEach(d => {
        const [r, c, s] = d;  // r = row center, c = col center, s = size

        // These ratios are from the original Pico.js demo – they give perfect face-only boxes
        const faceWidth = s * 0.9;     // Face is about 90% of detected square
        const faceHeight = s * 1.1;    // Slightly taller to include chin/forehead
        const x = c - faceWidth / 2;
        const y = r - faceHeight / 2 + s * 0.05; // Slight upward shift for better forehead coverage

        let left = Math.max(0, Math.round(x));
        let top = Math.max(0, Math.round(y));
        let width = Math.round(faceWidth);
        let height = Math.round(faceHeight);

        // Clamp to image bounds
        if (left + width > canvas.width) width = canvas.width - left;
        if (top + height > canvas.height) height = canvas.height - top;

        // Extract face
        const faceCanvas = document.createElement('canvas');
        faceCanvas.width = width;
        faceCanvas.height = height;
        const fctx = faceCanvas.getContext('2d');
        fctx.drawImage(canvas, left, top, width, height, 0, 0, width, height);

        // Strong pixelation
        const small = document.createElement('canvas');
        small.width = 12;
        small.height = 12;
        small.getContext('2d').drawImage(faceCanvas, 0, 0, 12, 12);

        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(small, left, top, width, height);
    });

    ctx.imageSmoothingEnabled = true;
    status.textContent = `Perfect! ${detections.length} face(s) blurred tightly. Click Download!`;
}

function showOriginal() {
    if (originalImageData) {
        ctx.putImageData(originalImageData, 0, 0);
        status.textContent = "Original image";
    }
}

function download() {
    canvas.toBlob(blob => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'faces-blurred-tight.png';
        a.click();
    });
    status.textContent = "Downloaded!";
}

window.blurFaces = blurFaces;
window.showOriginal = showOriginal;
window.download = download;

</script>
</body>
</html>
